fn map<T, V> (values: Iterator<T>, f: T -> V) -> Iterator<V> {
    return Iterator {
        next: () => f(values.next())
    }
}

// "indexed map": like .map, but takes a function with two inputs: the index of
// each element and the element itself
fn imap<T, V> (values: Iterator<T>, f: (uint, T) -> V) -> Iterator<V> {
    return values.enumerate().map(f)
}

// Returns the
// [composition](https://en.wikipedia.org/wiki/Function_composition) of f and
// g, such that h(x) = f(g(x)) for all x (note that the input here may in fact
// be several values). A variant of this function exists for repeated
// composition over a sequence of functions.
fn compose<T, U, V> (f: T -> U, g: U -> V) -> (T -> V) {
    return x => f(g(x))
}
fn compose<T> (fs : Sequence<T -> T>) -> (T -> T) {
    return fs.fold(compose)
}

// looping as a method on blocks of code?
// representations of closures/scoping?

// See https://en.wikipedia.org/wiki/Iterated_function.
fn iterate_func<T> (f : T -> T, n: uint) -> (T -> T) {
    return repeat(f, n).compose()
}

fn reduce<T> ((values: Iterator<T>), f: (T, T -> T), init: T) {
    values.each(v => init = f(init, v))
    return init
}
fn reduce_right<T> ((values: Iterator<T>), f: (T, T -> T), init: T) {
    values.each_right(v => init = f(init, v))
    return init
}
fn fold<T> (values: Iterator<T>, f: (T, T -> T)) {
    return reduce(values, f, values.first())
}
fn fold_right<T> (values: Iterator<T>, f: (T, T -> T)) {
    return reduce_right(values, f, values.first())
}

fn sum(values: Collection<T: Add>) {
    return values.fold(a, b => a + b)
}

fn max<T: Order>(a: T, b: T) {
    return a > b ? a : b
}
fn min<T: Order>(a: T, b: T) {
    return a < b ? a : b
}

fn max(values) {
    return values.fold(max)
}
fn min(values) {
    return values.fold(min)
}

// TODO: check that these are properly optimized (can be interleaved with max/min finding)
fn argmax<T: Iterator> (values) {
    return values.index(values.max())
}
fn argmin<T: Iterator> (values) {
    return values.index(values.min())
}

fn index<T: Sequence, V> (values: T<V>, x: T) -> Option<uint> {
    values.enumerate().each(i, v => {
        if v == x { return Some(i) }
    })
    // values.enumerate().filter(i, v => v == x).first()[0]
    return None
}

fn enumerate<T: Sequence, V> (values: T<V>) -> Sequence<(uint, V)> {
    return Sequence.zip(values, range(0, Infinity))
}


// Combines the provided iterators into a single iterator of tuples (see
// https://en.wikipedia.org/wiki/Zipping_(computer_science))
fn zip<T, V> (a: Sequence<T>, b: Sequence<V>) -> Sequence<(T, V)> {
    return Iterator {
        next: () => (a.next(), b.next())
    }
}

// Combines a sequence of sequences into an iterator over sequences where
// element j of input i is located at element i of element j of the output.
// Currently can only handle a single inner type (T) -- it should be fairly
// trivial to extend it once compile-time type value interfacing is available.
//
// This function is modelled loosely after https://stackoverflow.com/a/55292215
// (more compact, if we can get it to compile!). In the future, it should be
// possible to integrate parts of the Rust standard library into code developed
// with this framework (since one of the primary goals is interoperability).
fn zip<T> (values: Sequence<Sequence<T>>) -> Sequence<Tuple<T>> {
    // perhaps there is a nicer way to do this using .reduce and somehow
    // flattening each item in the result...
    return Iterator {
        next: () => values.map(.next)
    }
}

// A generic iterator trait, modelled after Rust's. An iterator must provide at
// least the `next` method, which (as the name implies) returns the next
// element in the sequence. Iterators can be finite or infinite; one special
// case is the iterator generated by the `cycle` function/method, which
// references a (potentially) finite number of values but is never exhausted.
trait Iterator<T> {
    // Returns the next element in this iterator, or `None` if there are no
    // more elements to return
    fn next () -> Option<T>
    optional fn length_bounds () -> range<uint>
}

fn cycle<T> (values: Sequence<T>) -> Iterator<T> {
    return Iterator {
        next: () => match values.next() {
            Some(value) => Some(value),
            None => values.clone().next()
        }
    }
}

fn replace<T> (values: Collection<T>, a: T, b: T) -> Collection<T> {
    return values.map(x => x == a ? b : x)
}

fn Add<T> (a: T, b: T) {
    return match T {
        // can we make this more generic (perhaps add some construct for
        // distributivity? or define by indices, i.e. c[i] = a[i] + b[i])
        Iterator => zip(a, b).map(ai, bi => ai + bi)
        String => String.cat(a, b)
        Number => a + b

        _ => raise error.notimplemented
    }
}

fn Eq<T> (a: T, b: T) {
    return match T {
        Iterator => zip(a, b).map(ai, bi => ai == bi).all()
        Number => a + b
        _ => raise error.notimplemented
    }
}


fn flatten(values: Collection<T | Collection>) {
    result = values.type.new()
    values.map(v => typecase {
        T: result.append(v)
        Collection: result.extend(flatten(v))
    })
    return result
}
flatten.tests {
    test.catch(flatten(1), error.type)
    test(flatten([42]) == [42])
    test(flatten([]) == [])
    test(flatten([[1, 2], 3, [[4, 5], [6, 7]]]) == [1, 2, 3, 4, 5, 6, 7])
    test(flatten(Set.new()) == Set.new())
}

fn Set.union<T> (a: Set<T>, b: Set<T>) ->
    c: (Set<T> where size >= max(a.size, b.size)) {

}
fn Set.union<T> (sets: Seq<Set<T>>) -> Set<T> {
    return sets.fold(.union)
}

// Returns a new set containing only the elements contained in both sets `a`
// and `b`
fn Set.intersection<T> (a: Set<T>, b: Set<T>) ->
    c: (Set<T> where size <= min(a.size, b.size)) {
    return a.filter(b.contains(it))
}
fn Set.union<T> (sets: Seq<Set<T>>) -> Set<T> {
    return sets.fold(.intersection)
}

fn Set.power_set<T> (set: Set<T>) ->
    Iterator<Set<T>; length == 2 ** set.size> {
    if set.size >= 16 : warn "The length of the output is exponential in the
    size of the input; an input this large is likely to take a very long time
    to complete. Consider testing with compiler flags for automatic process
    interruption to avoid indefinite program execution."


}


fn Iterator.product<T, V> (a: Iterator<T>, b: Iterator<V>) ->
    Iterator<(T, V); length == a.length * b.length> {
    // return Iterator { }
    return Iterator.chain(a.map(ai => b.map(bi => (ai, bi))))
}

println(Sequence.methods)

// A counter or multiset, similar to the one provided in Python
type Counter<T: Hash> {
    items: HashMap<T, uint>

    pub fn new (self, values: Collection<T>) {
        values.each(self.add)
        return self
    }

    pub fn add (self, x: T) {
        // if self.items.contains(x)
        match self.items.get(x) {
            Some(count) => count++
            None => self.items.insert(x, 0)
        }
        return self
    }

    pub fn to (self, t: type) -> t {
        match t {
            HashMap => self.items
            Set => Set.new(self.items.keys)
        }
    }
}
