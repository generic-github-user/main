fn map<T, V> (values: Iterator<T>, f: T -> V) -> Iterator<V> {
    return Iterator {
        next: () => f(values.next())
    }
}

// "indexed map": like .map, but takes a function with two inputs: the index of
// each element and the element itself
fn imap<T, V> (values: Iterator<T>, f: (uint, T) -> V) -> Iterator<V> {
    return values.enumerate().map(f)
}

// Returns the
// [composition](https://en.wikipedia.org/wiki/Function_composition) of f and
// g, such that h(x) = f(g(x)) for all x (note that the input here may in fact
// be several values). A variant of this function exists for repeated
// composition over a sequence of functions.
fn compose<T, U, V> (f: T -> U, g: U -> V) -> (T -> V) {
    return x => f(g(x))
}
fn compose<T> (fs : Sequence<T -> T>) -> (T -> T) {
    return fs.fold(compose)
}

// looping as a method on blocks of code?
// representations of closures/scoping?

// See https://en.wikipedia.org/wiki/Iterated_function.
fn iterate_func<T> (f : T -> T, n: uint) -> (T -> T) {
    return repeat(f, n).compose()
}

fn reduce<T> ((values: Iterator<T>), f: (T, T -> T), init: T) {
    values.each(v => init = f(init, v))
    return init
}
fn reduce_right<T> ((values: Iterator<T>), f: (T, T -> T), init: T) {
    values.each_right(v => init = f(init, v))
    return init
}
fn fold<T> (values: Iterator<T>, f: (T, T -> T)) {
    return reduce(values, f, values.first())
}
fn fold_right<T> (values: Iterator<T>, f: (T, T -> T)) {
    return reduce_right(values, f, values.first())
}

fn sum(values: Collection<T: Add>) {
    return values.fold(a, b => a + b)
}

// Simple binary maximum operator; returns whichever of its arguments is
// greater (`T` must be comparable via `>`). If equal, the first argument will
// be returned (this may matter for inputs that are equivalent according to
// `Eq` but correspond to different objects in memory).
fn max<T: Order>(a: T, b: T) {
    return a > b ? a : b
}
// Simple binary minimum operator; returns whichever of its arguments is
// smaller (`T` must be comparable via `<`). If equal, the first argument will
// be returned (this may matter for inputs that are equivalent according to
// `Eq` but correspond to different objects in memory).
fn min<T: Order>(a: T, b: T) {
    return a < b ? a : b
}

// Extends `max` to a collection of values; will fail if used on an empty
// collection. Worst case is linear time in the length of the input. As with
// `max(T, T)`, caution is needed when the elements of the input are `==` but
// not identical. Since we are folding from the first element onward, it will
// be the one returned if all the elements of `values` are equal.
fn max(values) {
    return values.fold(max)
}
// Extends `min` to a collection of values; will fail if used on an empty
// collection. Worst case is linear time in the length of the input. As with
// `min(T, T)`, caution is needed when the elements of the input are `==` but
// not identical. Since we are folding from the first element onward, it will
// be the one returned if all the elements of `values` are equal.
fn min(values) {
    return values.fold(min)
}

// Returns the index of the largest element in an ordered collection (or
// interface for accessing such a collection, like an Iterator). The elements
// of `values` must be comparable (that is, its inner type must implement
// `Order`). Returns `None` on an empty collection.
// 
// TODO: check that these are properly optimized (can likely be interleaved
// with max/min finding)
fn argmax <T: Iterator> (values) {
    complexity { time: O(n) }
    return values.index(values.max())
}
// Returns the index of the smallest element in an ordered collection (or
// interface for accessing such a collection, like an Iterator). The elements
// of `values` must be comparable (that is, its inner type must implement
// `Order`). Returns `None` on an empty collection.
fn argmin <T: Iterator> (values) {
    complexity { time: O(n) }
    return values.index(values.min())
}

fn index<T: Sequence, V> (values: T<V>, x: T) -> Option<uint> {
    values.enumerate().each(i, v => {
        if v == x { return Some(i) }
    })
    // values.enumerate().filter(i, v => v == x).first()[0]
    return None
}

fn enumerate<T: Sequence, V> (values: T<V>) -> Sequence<(uint, V)> {
    return Sequence.zip(values, range(0, Infinity))
}


// Combines the provided iterators into a single iterator of tuples (see
// https://en.wikipedia.org/wiki/Zipping_(computer_science))
fn zip<T, V> (a: Sequence<T>, b: Sequence<V>) -> Sequence<(T, V)> {
    return Iterator {
        next: () => (a.next(), b.next())
    }
}

// Combines a sequence of sequences into an iterator over sequences where
// element j of input i is located at element i of element j of the output.
// Currently can only handle a single inner type (T) -- it should be fairly
// trivial to extend it once compile-time type value interfacing is available.
//
// This function is modelled loosely after https://stackoverflow.com/a/55292215
// (more compact, if we can get it to compile!). In the future, it should be
// possible to integrate parts of the Rust standard library into code developed
// with this framework (since one of the primary goals is interoperability).
fn zip<T> (values: Sequence<Sequence<T>>) -> Sequence<Tuple<T>> {
    // perhaps there is a nicer way to do this using .reduce and somehow
    // flattening each item in the result...
    return Iterator {
        next: () => values.map(.next)
    }
}

// A generic iterator trait, modelled after Rust's. An iterator must provide at
// least the `next` method, which (as the name implies) returns the next
// element in the sequence. Iterators can be finite or infinite; one special
// case is the iterator generated by the `cycle` function/method, which
// references a (potentially) finite number of values but is never exhausted.
trait Iterator<T> {
    // Returns the next element in this iterator, or `None` if there are no
    // more elements to return
    fn next () -> Option<T>
    optional fn length_bounds () -> range<uint>
}

fn cycle<T> (values: Sequence<T>) -> Iterator<T> {
    return Iterator {
        next: () => match values.next() {
            Some(value) => Some(value),
            None => values.clone().next()
        }
    }
}

fn replace<T> (values: Collection<T>, a: T, b: T) -> Collection<T> {
    return values.map(x => x == a ? b : x)
}

fn Add<T> (a: T, b: T) {
    return match T {
        // can we make this more generic (perhaps add some construct for
        // distributivity? or define by indices, i.e. c[i] = a[i] + b[i])
        Iterator => zip(a, b).map(ai, bi => ai + bi)
        String => String.cat(a, b)
        Number => a + b

        _ => raise error.notimplemented
    }
}

fn Eq<T> (a: T, b: T) {
    return match T {
        Iterator => zip(a, b).map(ai, bi => ai == bi).all()
        Number => a + b
        _ => raise error.notimplemented
    }
}


fn flatten(values: Collection<T | Collection>) {
    result = values.type.new()
    values.map(v => typecase {
        T: result.append(v)
        Collection: result.extend(flatten(v))
    })
    return result
}
flatten.tests {
    test.catch(flatten(1), error.type)
    test(flatten([42]) == [42])
    test(flatten([]) == [])
    test(flatten([[1, 2], 3, [[4, 5], [6, 7]]]) == [1, 2, 3, 4, 5, 6, 7])
    test(flatten(Set.new()) == Set.new())
}

fn Set.union<T> (a: Set<T>, b: Set<T>) ->
    c: (Set<T> where size >= max(a.size, b.size)) {

}
fn Set.union<T> (sets: Seq<Set<T>>) -> Set<T> {
    return sets.fold(.union)
}

// Returns a new set containing only the elements contained in both sets `a`
// and `b`
fn Set.intersection<T> (a: Set<T>, b: Set<T>) ->
    c: (Set<T> where size <= min(a.size, b.size)) {
    return a.filter(b.contains(it))
}
fn Set.union<T> (sets: Seq<Set<T>>) -> Set<T> {
    return sets.fold(.intersection)
}

fn Set.power_set<T> (set: Set<T>) ->
    Iterator<Set<T>; length == 2 ** set.size> {
    if set.size >= 16 : warn "The length of the output is exponential in the
    size of the input; an input this large is likely to take a very long time
    to complete. Consider testing with compiler flags for automatic process
    interruption to avoid indefinite program execution."


}

// to what extent can this be handled at the compiler level?
fn memoize (f: (in: *(Any: Hash)) -> (out: Any), limit: uint)
    -> (*Any -> Any) {

    return Object {
        cache: HashMap<in, out> = HashMap.new(),
        call: (in -> out) = (inputs: in) => {
            assert cache.size <= limit
            match cache.get(inputs) {
                Some(value) => value.x
                None => {
                    output = f(inputs)
                    if cache.size == limit {
                        cache.remove(cache.min_by(.count))
                    }
                    cache.insert(inputs, Object {
                        x: output,
                        count: 1
                    })
                    return output.x
                }
            }
        }
    }
}

fn Iterator.product<T, V> (a: Iterator<T>, b: Iterator<V>) ->
    Iterator<(T, V); length == a.length * b.length> {
    // return Iterator { }
    return Iterator.chain(a.map(ai => b.map(bi => (ai, bi))))
}

println(Sequence.methods)

// A counter or multiset, similar to the one provided in Python
type Counter<T: Hash> {
    items: HashMap<T, uint>

    pub fn new (self, values: Collection<T>) {
        values.each(self.add)
        return self
    }

    pub fn add (self, x: T) {
        // if self.items.contains(x)
        match self.items.get(x) {
            Some(count) => count++
            None => self.items.insert(x, 0)
        }
        return self
    }

    pub fn to (self, t: type) -> t {
        match t {
            HashMap => self.items
            Set => Set.new(self.items.keys)
        }
    }
}


trait PartialEq {}

trait Eq {
    tags : { symmetric, transitive, reflexive }
    pub fn eq <T> (a: T, b: T) -> bool
    optional pub fn neq <T> (a: T, b: T) -> bool
    eq(x, y) == !neq(x, y)
}

// interpret refinement types as subtypes?
// e.g., T: Vec
// "subclassing" functions?

linalg.dot <T: Number> (a: Vec<T>, b: Vec<T>) where a.length == b.length
    -> Vec<T; .length == a.length == b.length> {
    complexity { time: O(n) }

    // return (a * b).sum()
    return zip(a, b).map(T.mul).sum()
}

pub mut fn Sequence.shuffle <T> (values: Sequence<T>) ->
    Sequence<T; .length == values.length> {
    complexity { time: O(n) }

    ((n-1)..1).each(i => {
        let j = random.int(0, i+1)
        values.swap(i, j)
    })
    return values
}

pub fn Sequence.shuffled <T> (values: Sequence<T>) ->
    Sequence<T; .length == values.length> {
    complexity { time: O(n) }

    return values.clone().shuffle()
}
// Sequence.shuffled = cloner(Sequence.shuffle)


@memoize
pub fn math.factorial (x : Number) -> Number {
    range(1, x+1).product()
}
