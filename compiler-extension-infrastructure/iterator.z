fn map<T, V> (values: Iterator<T>, f: T -> V) -> Iterator<V> {
    return Iterator {
        next: () => f(values.next())
    }
}

// "indexed map": like .map, but takes a function with two inputs: the index of
// each element and the element itself
fn imap<T, V> (values: Iterator<T>, f: (uint, T) -> V) -> Iterator<V> {
    return values.enumerate().map(f)
}

fn reduce<T> (values: Iterator<T>, f: (T, T -> T), init: T) -> T {
    values.each(v => init = f(init, v))
    return init
}
fn reduce_right<T> (values: Iterator<T>, f: (T, T -> T), init: T) -> T {
    values.each_right(v => init = f(init, v))
    return init
}
fn fold<T> (values: Iterator<T>, f: (T, T -> T)) -> Option<T> {
    return reduce(values, f, values.first())
}
fn fold_right<T> (values: Iterator<T>, f: (T, T -> T)) -> Option<T> {
    return reduce_right(values, f, values.first())
}

fn sum(values: Collection<T: Add>) -> T {
    return values.fold(a, b => a + b)
}


fn index<T: Sequence, V> (values: T<V>, x: T) -> Option<uint> {
    values.enumerate().each(i, v => {
        if v == x { return Some(i) }
    })
    // values.enumerate().filter(i, v => v == x).first()[0]
    return None
}

fn enumerate<T: Sequence, V> (values: T<V>) -> Sequence<(uint, V)> {
    return Sequence.zip(values, range(0, Infinity))
}


// Combines the provided iterators into a single iterator of tuples (see
// https://en.wikipedia.org/wiki/Zipping_(computer_science))
fn zip<T, V> (a: Sequence<T>, b: Sequence<V>) -> Sequence<(T, V)> {
    return Iterator {
        next: () => (a.next(), b.next())
    }
}

// Combines a sequence of sequences into an iterator over sequences where
// element j of input i is located at element i of element j of the output.
// Currently can only handle a single inner type (T) -- it should be fairly
// trivial to extend it once compile-time type value interfacing is available.
//
// This function is modelled loosely after https://stackoverflow.com/a/55292215
// (more compact, if we can get it to compile!). In the future, it should be
// possible to integrate parts of the Rust standard library into code developed
// with this framework (since one of the primary goals is interoperability).
fn zip<T> (values: Sequence<Sequence<T>>) -> Sequence<Tuple<T>> {
    // perhaps there is a nicer way to do this using .reduce and somehow
    // flattening each item in the result...
    return Iterator {
        next: () => values.map(.next)
    }
}

// A generic iterator trait, modelled after Rust's. An iterator must provide at
// least the `next` method, which (as the name implies) returns the next
// element in the sequence. Iterators can be finite or infinite; one special
// case is the iterator generated by the `cycle` function/method, which
// references a (potentially) finite number of values but is never exhausted.
trait Iterator<T> {
    // Returns the next element in this iterator, or `None` if there are no
    // more elements to return
    fn next () -> Option<T>
    optional fn length_bounds () -> range<uint>
}

fn cycle<T> (values: Sequence<T>) -> Iterator<T> {
    return Iterator {
        next: () => match values.next() {
            Some(value) => Some(value)
            None => values.clone().next()
        }
    }
}
