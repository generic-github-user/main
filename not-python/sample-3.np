class Point:
    pos: np.ndarray
    precision: int

    def __init__(self, pos: list, p: int = 8):
        """
        Create a new Point instance
        Params:
            pos: The new point's position in the coordinate system
            p: The level of precision to store the point's position with
        """

        # super(Geometry, self).__init__()
        super().__init__(dimensions=0)
        self.pos = np.array(pos, dtype=float)
        self.precision = p
        self.update()

    def update(self):
        varnames = 'xyzw'
        for i, axis in enumerate(self.pos):
            setattr(self, varnames[i], self.pos[i])
        return self

    def move(self, delta: list):
        """
        Translate the point
        Params:
            delta: A list of offsets to move the point along each axis in space
            by
        """
        self.pos += np.array(delta)
        self.update()
        return self

    def rotate(self, a: list, theta: int, rad: float = None):
        """
        Rotate the point about another
        Params:
            a: The point to rotate about
            theta: The rotation to apply to the point, in degrees
            rad: The rotation in radians (supersedes `theta`)
        """
        theta = float(theta)
        # Convert to radians
        if not rad:
            theta = theta * math.pi / 180

        # Create a rotation matrix to apply a rotation to the point
        rotation_matrix = [
            [np.cos(theta), -np.sin(theta)],
            [np.sin(theta), np.cos(theta)]
        ]

        # Move the point so its coordinate is relative to the origin
        self.move(-a.pos)

        # Apply the rotation matrix
        self.pos = np.dot(self.pos, rotation_matrix)

        # Move point back
        self.move(a.pos)

        # Round to specified precision
        self.pos = self.pos.round(self.precision)

        self.update()
        return self

    def __add__(self, B):
        return Point(self.pos + B.pos)

    def __sub__(self, B):
        return Point(self.pos - B.pos)

    def __mul__(self, B):
        return Point(self.pos * B.pos)

    def __truediv__(self, B):
        if isinstance(B, Point):
            return Point(self.pos / B.pos)
        elif isinstance(B, (int, float)):
            return Point(self.pos / B)

    def __call__(self):
        """
        Returns this point's position
        """
        return self.pos

    def print(self):
        print(self)
        return self

    def __str__(self):
        """
        Generate a string representation of this point
        """
        return 'Point ' + str(self.pos)
