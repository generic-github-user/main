use super::token::Token;
use super::chartype::CharType;
use super::node::{Node, NodeType};

pub fn parse(tokens: Vec<Token>, verbose: bool) -> Node {
    // a list of indices representing a path through the abstract syntax tree generated by the
    // parser; used to keep track of the current parsing context
    let mut stack = Vec::<usize>::new();
    // stack.push(0);
    let mut indentlevel: usize = 0;
    let mut ptoken: Option<Token> = None;

    let mut root = Node {
        content: None,
        children: vec![],
        nodetype: NodeType::Program
    };

    for token in tokens {
        // if token.chartype == CharType::LeftSB {
        match token.chartype {
            // A left bracket ([) opens a new form ...
            CharType::LeftSB => {
                if verbose {
                    println!("Found {} with type {:?}; opening form/expression node",
                              token, token.chartype);
                }

                let nnode = Node {
                    content: None,
                    children: vec![],
                    nodetype: NodeType::Form
                };

                let current = root.get(stack.clone());
                // stack.push(current.children.len());
                stack.push(current.children.len());
                current.children.push(nnode);
            }

            // ... and a right bracket (]) closes it
            CharType::RightSB => {
                if verbose {
                    println!("Found {} with type {:?}; closing form/expression node",
                              token, token.chartype);
                }
                stack.pop();
            }

            // An identifier or expression within a form
            CharType::Letter | CharType::Symbol
                | CharType::String | CharType::Digit => {

                if verbose {
                    println!("Found {} with type {:?}; inserting (sub)node into current form",
                              token, token.chartype);
                }

                let current = root.get(stack.clone());
                let nnode = Node {
                    content: Some(token.clone()),
                    children: vec![],
                    nodetype: match token.chartype {
                        CharType::Letter | CharType::Symbol => NodeType::Token,
                        CharType::String => NodeType::String,
                        CharType::Digit => NodeType::Integer,
                        _ => unreachable!()
                    }
                };
                current.children.push(nnode);

                // we're adding a new bottom-level node (leaf) to the parent of the last node in
                // the current path
                //if stack.len() == 0 {
                    //stack.push(0);
                //} else {
                   //*stack.last_mut().unwrap() += 1;
                //}
            }

            // Whitespace between tokens/forms or at the beginning of a line (i.e., indentation
            // used to denote sub-forms)
            CharType::Whitespace => {
                if ptoken.is_some() && ptoken.unwrap().chartype == CharType::Newline {
                    if verbose {
                        println!("Found {} with type {:?} (leading whitespace) ...",
                                  token, token.chartype);
                    }

                    if token.content.len() > indentlevel {
                        // TODO: abstract this out into a function
                        let nnode = Node {
                            content: None,
                            children: vec![],
                            nodetype: NodeType::Form
                        };

                        let current = root.get(stack.clone());
                        stack.push(current.children.len());
                        current.children.push(nnode);
                    } else if token.content.len() == indentlevel {
                        // TODO: abstract this out into a function
                        let current = root.get(stack.clone());
                        let nnode = Node {
                            content: Some(token.clone()),
                            children: vec![],
                            nodetype: NodeType::Whitespace
                        };
                        current.children.push(nnode);
                    } else {
                        assert!(token.content.len() < indentlevel);
                        // let current = root.get();
                        // stack.truncate
                        for i in 0..(indentlevel - token.content.len()) {
                            stack.pop();
                        }
                    }

                    indentlevel = token.content.len();
                }
            }

            CharType::Newline => {

            }

            CharType::None => {

            }

            CharType::Quote | CharType::Unknown => {

            }

            CharType::Alphanumeric => unreachable!()
        }

        ptoken = Some(token.clone());
    }

    return root;
}
