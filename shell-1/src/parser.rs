use super::token::Token;
use super::node::Node;
use super::node::NodeType;
use super::chartype::CharType;

fn descend(root: &mut Node, context: &mut Vec<usize>) {
    let nnode = Node {
        content: None,
        children: vec![],
        nodetype: NodeType::Block
    };

    let current = root.get(context.clone());
    context.push(current.children.len());
    current.children.push(nnode);
}


pub fn parse(tokens: Vec<Token>, verbose: bool) -> Node {
    // a list of indices representing a path through the abstract syntax tree generated by the
    // parser; used to keep track of the current parsing context
    let mut stack = Vec::<usize>::new();
    let mut root = Node {
        content: None,
        children: vec![],
        nodetype: NodeType::Program
    };
    for token in tokens {
        match token.chartype {
            CharType::Letter | CharType::Digit => {
                let current = root.get(stack.clone());
                current.children.push(Node {
                    content: Some(token),
                    children: vec![],
                    nodetype: NodeType::String
                });
            }
            CharType::Symbol => {
                match token.content.as_str() {
                    "{" => {
                        descend(&mut root, &mut stack);
                    },
                    "}" => {
                        stack.pop();
                    },
                    _ => todo!()
                }
            }
            CharType::Newline | CharType::Whitespace | CharType::None => (),
            _ => todo!("{:?}", token.chartype)
        }
    }

    return root;
}
