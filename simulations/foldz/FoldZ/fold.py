# AUTOGENERATED! DO NOT EDIT! File to edit: 00_fold.ipynb (unless otherwise specified).

__all__ = ['Geometry', 'Point', 'Line', 'Polygon', 'RegularPolygon', 'r', 'Circle', 'Manifold', 'Event', 'Foldable',
           'F']

# Cell
%matplotlib widget
import matplotlib.pyplot as plt
import svgwrite

# Cell
import sympy
from sympy import Point2D, Point3D, Segment, Polygon, N, Rational, pi
from sympy.abc import x, y, z, t

import math
import numpy as np
import random

# Cell
import time
from IPython.display import display, SVG

# Cell
class Geometry:
    """Generalized multidimensional shape class"""
    def __init__(self, parts=None, dimensions=None):
        """Create a new geometry object"""

        if parts:
            self.parts = parts
        else:
            self.parts = []

        if dimensions is None:
            self.dimensions = self.parts[0].dimensions + 1
        else:
            self.dimensions = dimensions

# Cell

# class Point(Geometry):
#     def __init__(self):
#         # super(Geometry, self).__init__()
#         super().__init__(dimensions=0)

class Point:
    pos: np.ndarray
    precision: int

    def __init__(self, pos:list, p:int=8):
        """
        Create a new Point instance

        Params:
            pos: The new point's position in the coordinate system
            p: The level of precision to store the point's position with
        """
        self.pos = np.array(pos, dtype=float)
        self.precision = p
        self.update()

    def update(self):
        varnames = 'xyzw'
        for i, axis in enumerate(self.pos):
            setattr(self, varnames[i], self.pos[i])
        return self

    def move(self, delta:list):
        """
        Translate the point

        Params:
            delta: A list of offsets to move the point along each axis in space by
        """
        self.pos += np.array(delta)
        self.update()
        return self

    def rotate(self, a:list, theta:int, rad:float=None):
        """
        Rotate the point about another

        Params:
            a: The point to rotate about
            theta: The rotation to apply to the point, in degrees
            rad: The rotation in radians (supersedes `theta`)
        """
        theta = float(theta)
        # Convert to radians
        if not rad:
            theta = theta * math.pi / 180
        # Create a rotation matrix to apply a rotation to the point
        rotation_matrix = [
            [np.cos(theta), -np.sin(theta)],
            [np.sin(theta), np.cos(theta)]
        ]
#         print(rotation_matrix)
#         self.pos *= rotation_matrix

        # Move the point so its coordinate is relative to the origin
        self.move(-a.pos)
        # Apply the rotation matrix
        self.pos = np.dot(self.pos, rotation_matrix)
        # Move point back
        self.move(a.pos)
        # Round to specified precision
        self.pos = self.pos.round(self.precision)
        self.update()
        return self

    def __add__(self, B):
        return Point(self.pos + B.pos)

    def __sub__(self, B):
        return Point(self.pos - B.pos)

    def __mul__(self, B):
        return Point(self.pos * B.pos)

    def __truediv__(self, B):
        if isinstance(B, Point):
            return Point(self.pos / B.pos)
        elif isinstance(B, (int, float)):
            return Point(self.pos / B)

    def __call__(self):
        """
        Returns this point's position
        """
        return self.pos

    def print(self):
        print(self)
        return self

    def __str__(self):
        """
        Generate a string representation of this point
        """
        return 'Point ' + str(self.pos)


# Cell

# # 1D geometry convenience subclass
# class Line(Geometry):
#     def __init__(self):
#         super().__init__(dimensions=1)
# global geometry sessions
class Line:
    def __init__(self, a, b):
        """Create a new line

        Params:
            a: The start point of the line
            b: The end point of the line
        """
        self.a = a
        self.b = b

    def move(self, delta):
        """Translate the line

        Params:
            delta: The amount (in each direction/axis) to move the line by
        """
        for p in [self.a, self.b]:
            p.move(delta)
        return self

    def rotate(self, *args, **kwargs):
        for p in [self.a, self.b]:
            p.rotate(*args, **kwargs)
        return self

    def divide(self, n:int=1) -> list['Line']:
        """Split the line into several smaller line segments

        Params:
            n: The number of sections to divide the line into
        """
#         return [Line(Point(np.average([self.a, self.b], weights=[]))) for i in range(n)]
        sections = []
        for i in range(n):
            a_ = np.average([self.a(), self.b()], weights=[i, n-i], axis=0)
            b_ = np.average([self.a(), self.b()], weights=[i+1, n-i-1], axis=0)
            s = Line(
                Point(b_),
                Point(a_),
            )
            sections.append(s)
        return sections[::-1]

    def intersects(self, B):
#         return any([((Y.pos > Z.pos).all() or (Y.pos < Z.pos).all()) for Y, Z in [(self.a, B.a), (self.b, B.b)]])
#         if not (min(self.a.x, self.b.x) > min(self.a.x, self.b.x) or max(self.a.x, self.b.x) < max(self.a.x, self.b.x)):
#             return False
        if all([P >= max(B.a.x, B.b.x) for P in [self.a.x, self.b.x]]) or all([P <= min(B.a.x, B.b.x) for P in [self.a.x, self.b.x]]):
            return False
        elif all([P >= max(B.a.y, B.b.y) for P in [self.a.y, self.b.y]]) or all([P <= min(B.a.y, B.b.y) for P in [self.a.y, self.b.y]]):
            return False
        else:
            solution = self.solve(B)
            if solution:
    #             Check that solution is within bounds of both line segments (only need to check one axis)
                if (self.a.x <= solution.x <= self.b.x) or (self.a.x >= solution.x >= self.b.x):
                    if (B.a.x <= solution.x <= B.b.x) or (B.a.x >= solution.x >= B.b.x):
                        return True
    #             else:
    #                 print('Not in bounds')
            else:
                return False

    def intersection(self, L2):
        if self.intersects(L2):
            return self.solve(L2)

    def midpoint(self):
        return (self.a + self.b) / 2

    def slope(self):
        return (self.a.y - self.b.y) / (self.a.x - self.b.x)

    def yintercept(self):
        return self.a - Point((self.a.x, self.a.x*self.slope()))

    def coefficients(self):
#         - ?
        return [-self.slope(), 1, self.yintercept().y]

    def solve(self, L2):
        try:
            A, B = self.coefficients(), L2.coefficients()
            solution = np.linalg.solve(np.array([A[:2], B[:2]]), np.array([A[-1], B[-1]]))
            return Point(solution)
        except:
            return False

    def __str__(self):
        return 'Line\n\t' + '\n\t'.join(str(v) for v in [self.a, self.b])

    def __repr__(self):
        return str(self)

# Cell
# 2D geometry convenience subclass
class Shape(Geometry):
    def __init__(self):
        super().__init__(dimensions=2)

# Cell
# 3D geometry convenience subclass
class Solid(Geometry):
    def __init__(self):
        super().__init__(dimensions=3)

# Cell
# 4D geometry convenience subclass
class Hypersolid(Geometry):
    def __init__(self):
        super().__init__(dimensions=4)

# Cell
# should this subclass Geometry instead?
class Polygon(Shape):
    """General polygon class that extends the Shape class"""
    def __init__(self):
        """Create a new polygon"""
        super().__init__()
        self.sides: [line] = []
        self.vertices = self.v = []

    def regular(self, sides, radius):
        """Define polygon's geometry as a regular polygon; one with equal sides and angles"""
        for s in range(sides):
            self.sides.append(Line())

    def rotate(self, *args, **kwargs):
        for p in self.v:
            p.rotate(*args, **kwargs)
        return self

    def __str__(self):
        return 'Polygon\n\t' + '\n\t'.join(str(v) for v in self.v)

    def __repr__(self):
        return str(self)

# Cell
class RegularPolygon(Polygon):
    def __init__(self, r=1, n=4, c=None, manifold=2, axis=0):
        super().__init__()
        start = [0] * manifold
        start[axis] = r
        self.v.append(Point(start))
        if not c:
            c = Point([0] * manifold)
        self.center = c
        for i in range(n-1):
            self.v.append(Point(self.v[-1].pos).rotate(c, 360 / n, axis=axis))
# Cell
class Circle(Shape):
    """A geometric 2D circle with a certain radius; subclass of Shape"""
    def __init__(self, radius):
        super().__init__()
        self.radius: Scalar = radius
    def get_tangents(self):
        """Quickly calculate incline angle of tangent line for each cell rendered on circle outline; these will be used to render the outline in ASCII characters"""
        r = self.radius()
        # possibly move this code
        minigrid = np.zeros([r*2+1, r*2+1])
        # crossed_cells = minigrid
        # TODO: mirroring for efficiency?
        for x, y in np.ndindex(minigrid.shape):
            # print(5)
            # print(np.round(np.linalg.norm(np.array([x, y]) - np.array([r, r]))))
            if np.round(np.linalg.norm(np.array([x, y]) - np.array([r, r]))) == r:
                minigrid[x, y] = 1
        num_crossed = np.sum(minigrid)
        d_theta = 360 / num_crossed
        c = 0
        for x, y in np.ndindex(minigrid.shape):
            # if
            c += minigrid[x, y]
            # minigrid[x, y] = Angle(d_theta * c)
            minigrid[x, y] = d_theta * c * minigrid[x, y]
        return np.round(minigrid)

# Cell
class Manifold:
    def __init__(self, dimensions=2):
        assert dimensions >= 1
        self.dimensions = dimensions

# Cell
class Event:
    def __init__(self):
        self.time = time.time()

    def __str__(self):
        return str(self.time)

    def __repr__(self):
        return str(self)

# Cell
class Foldable:
    def __init__(self, shape, manifold, exact=True, backend='geo'):
        if not isinstance(shape, (list, tuple)):
            shape = [shape]
        self.shape = shape
        self.manifold = manifold
        self.exact = exact
        self.backend = backend

    def render(self, filename='./rendered.svg', size=(400, 400), center=True, color='white', color_mapping='hue', color_by='order', style={}):
        image = svgwrite.Drawing(filename=filename, size=size)
        if self.backend == 'sympy':
            offset = Point2D(size)/2-self.shape[0].midpoint
        elif self.backend in ['geo', 'geometry']:
            offset = Point(size)/2-self.shape[0].midpoint()
        for i, part in enumerate(self.shape):
            if isinstance(part, Segment):
                p1 = self.plain(part.p1+offset)
                p2 = self.plain(part.p2+offset)
            elif isinstance(part, Line):
                p1 = (part.a+offset).pos
                p2 = (part.b+offset).pos
            if color_by == 'order':
                style |= {'style': f'stroke:hsl({round(i/len(self.shape)*360)}, 100%, 50%)'}
            line = image.line(
                start=p1,
                end=p2,
                stroke=color,
                stroke_width=1,
                **style
            )
            image.add(line)
        image.save()
        return self

    def rotate_section(self, index, center, rotation, direction='forward'):
        """
        Rotate a linkage section and all the attached sections (repeating until the end of the chain is reached)
        """

        if direction == 'random':
            direction = random.choice(['forward', 'backward'])
        if direction == 'forward':
            R = range(index+1, len(self.shape))
        elif direction == 'backward':
            R = range(len(self.shape)-1, index, -1)
        for p in R:
            self.shape[p].rotate(center, rotation, rad=True)
        return self

    def self_intersections(self):
        intersections = []
        for p in self.shape:
            for q in self.shape:
                if p is not q and p.intersects(q):
                    intersections.append(p.intersection(q))
        return intersections

    def intersects_self(self):
        for p in self.shape:
            for q in self.shape:
                if p is not q and p.intersects(q):
                    return True
        self.events.append(Event())
        return False

    def random_fold(self, allow_intersection=False, attempts=20):
        part = random.choice(self.shape)
        index = self.shape.index(part)

#         v = round(random.uniform(0, 1), 2)
        if self.backend == 'sympy':
            v = Rational(random.randint(1, 3)/4)
            split = part.arbitrary_point(parameter=t).subs(t, v)
#         elif self.backend == 'geo':

            if not self.exact:
                split = self.plain(split)
    #             split = list(map(sympy.Expr, split))
    #         self.shape.pop(self.shape.index(part))
            p1, p2 = part.p1, part.p2
            if not self.exact:
                p1, p2 = map(self.plain, [p1, p2])
            self.shape[index:index+1] = [Segment(p1, split), Segment(split, p2)]
            rotation = random.choice([pi/2,-pi/2])
            for p in range(index+1, len(self.shape)):
                self.shape[p] = self.shape[p].rotate(rotation, split)
        elif self.backend in ['geo', 'geometry']:
            if allow_intersection:
                rotation = random.uniform(0, 2*math.pi*0.2)
                sections = part.divide(2)
                self.shape[index:index+1] = sections
                self.rotate_section(index, part.midpoint(), rotation)
            else:
                success = False
                for j in range(attempts):
#                     why does the search often fail if these lines are not included?
                    part = random.choice(self.shape)
                    index = self.shape.index(part)

        #             rotation = random.choice([math.pi/6,-math.pi/6])
                    eta = 2*math.pi*1
                    rotation = random.uniform(-eta, eta)
                    sections = part.divide(2)
                    self.shape[index:index+1] = sections
                    D = random.choice(['forward', 'backward'])
                    self.rotate_section(index, part.midpoint(), rotation, direction=D)
    #                 add undo function
                    if self.intersects_self():
                        self.rotate_section(index, part.midpoint(), -rotation, direction=D)
                        self.shape[index:index+len(sections)] = [part]
                    else:
                        success = True
                        break
                if not success:
                    print(f'Could not find suitable configuration within {attempts} attempts')

#             print(part.midpoint(), self.shape)
        return self

# F = Foldable(Segment(Point2D(0, 0), Point2D(100, 0)), Manifold())
F = Foldable(Line(Point((0,0)), Point((200,0))), Manifold())
for i in range(10):
#     F.random_fold()
#     F.render(clear=False)
    F.random_fold(allow_intersection=False, attempts=100)

# F.render(style={'style':'stroke:hsl(0, 100%, 50%)'}).show()
F.render(clear=False).show()
# constraint optimization
# interactive mode
# add M/V fold markings
# voronoi diagram generation
# memoize intersection detection
# folding ring linkages
# numpy (syntax/style) for geometry