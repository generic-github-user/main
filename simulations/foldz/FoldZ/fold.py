# AUTOGENERATED! DO NOT EDIT! File to edit: 00_fold.ipynb (unless otherwise specified).

__all__ = ['Geometry', 'Point', 'Line', 'Polygon', 'RegularPolygon', 'r', 'Circle', 'Manifold', 'Event', 'Foldable',
           'F']

# Cell
%matplotlib widget
import matplotlib.pyplot as plt
import svgwrite

# Cell
import sympy
from sympy import Point2D, Point3D, Segment, Polygon, N, Rational, pi
from sympy.abc import x, y, z, t

import math
import numpy as np
import random

# Cell
import time
from IPython.display import display, SVG

# Cell
class Circle(Shape):
    """A geometric 2D circle with a certain radius; subclass of Shape"""
    def __init__(self, radius):
        super().__init__()
        self.radius: Scalar = radius
    def get_tangents(self):
        """Quickly calculate incline angle of tangent line for each cell rendered on circle outline; these will be used to render the outline in ASCII characters"""
        r = self.radius()
        # possibly move this code
        minigrid = np.zeros([r*2+1, r*2+1])
        # crossed_cells = minigrid
        # TODO: mirroring for efficiency?
        for x, y in np.ndindex(minigrid.shape):
            # print(5)
            # print(np.round(np.linalg.norm(np.array([x, y]) - np.array([r, r]))))
            if np.round(np.linalg.norm(np.array([x, y]) - np.array([r, r]))) == r:
                minigrid[x, y] = 1
        num_crossed = np.sum(minigrid)
        d_theta = 360 / num_crossed
        c = 0
        for x, y in np.ndindex(minigrid.shape):
            # if
            c += minigrid[x, y]
            # minigrid[x, y] = Angle(d_theta * c)
            minigrid[x, y] = d_theta * c * minigrid[x, y]
        return np.round(minigrid)

# Cell
class Manifold:
    def __init__(self, dimensions=2):
        assert dimensions >= 1
        self.dimensions = dimensions

# Cell
class Event:
    def __init__(self):
        self.time = time.time()

    def __str__(self):
        return str(self.time)

    def __repr__(self):
        return str(self)

# Cell
class Foldable:
    def __init__(self, shape, manifold, exact=True, backend='geo'):
        if not isinstance(shape, (list, tuple)):
            shape = [shape]
        self.shape = shape
        self.manifold = manifold
        self.exact = exact
        self.backend = backend

    def render(self, filename='./rendered.svg', size=(400, 400), center=True, color='white', color_mapping='hue', color_by='order', style={}):
        image = svgwrite.Drawing(filename=filename, size=size)
        if self.backend == 'sympy':
            offset = Point2D(size)/2-self.shape[0].midpoint
        elif self.backend in ['geo', 'geometry']:
            offset = Point(size)/2-self.shape[0].midpoint()
        for i, part in enumerate(self.shape):
            if isinstance(part, Segment):
                p1 = self.plain(part.p1+offset)
                p2 = self.plain(part.p2+offset)
            elif isinstance(part, Line):
                p1 = (part.a+offset).pos
                p2 = (part.b+offset).pos
            if color_by == 'order':
                style |= {'style': f'stroke:hsl({round(i/len(self.shape)*360)}, 100%, 50%)'}
            line = image.line(
                start=p1,
                end=p2,
                stroke=color,
                stroke_width=1,
                **style
            )
            image.add(line)
        image.save()
        return self

    def rotate_section(self, index, center, rotation, direction='forward'):
        """
        Rotate a linkage section and all the attached sections (repeating until the end of the chain is reached)
        """

        if direction == 'random':
            direction = random.choice(['forward', 'backward'])
        if direction == 'forward':
            R = range(index+1, len(self.shape))
        elif direction == 'backward':
            R = range(len(self.shape)-1, index, -1)
        for p in R:
            self.shape[p].rotate(center, rotation, rad=True)
        return self

    def self_intersections(self):
        intersections = []
        for p in self.shape:
            for q in self.shape:
                if p is not q and p.intersects(q):
                    intersections.append(p.intersection(q))
        return intersections

    def intersects_self(self):
        for p in self.shape:
            for q in self.shape:
                if p is not q and p.intersects(q):
                    return True
        self.events.append(Event())
        return False

    def random_fold(self, allow_intersection=False, attempts=20):
        part = random.choice(self.shape)
        index = self.shape.index(part)

#         v = round(random.uniform(0, 1), 2)
        if self.backend == 'sympy':
            v = Rational(random.randint(1, 3)/4)
            split = part.arbitrary_point(parameter=t).subs(t, v)
#         elif self.backend == 'geo':

            if not self.exact:
                split = self.plain(split)
    #             split = list(map(sympy.Expr, split))
    #         self.shape.pop(self.shape.index(part))
            p1, p2 = part.p1, part.p2
            if not self.exact:
                p1, p2 = map(self.plain, [p1, p2])
            self.shape[index:index+1] = [Segment(p1, split), Segment(split, p2)]
            rotation = random.choice([pi/2,-pi/2])
            for p in range(index+1, len(self.shape)):
                self.shape[p] = self.shape[p].rotate(rotation, split)
        elif self.backend in ['geo', 'geometry']:
            if allow_intersection:
                rotation = random.uniform(0, 2*math.pi*0.2)
                sections = part.divide(2)
                self.shape[index:index+1] = sections
                self.rotate_section(index, part.midpoint(), rotation)
            else:
                success = False
                for j in range(attempts):
#                     why does the search often fail if these lines are not included?
                    part = random.choice(self.shape)
                    index = self.shape.index(part)

        #             rotation = random.choice([math.pi/6,-math.pi/6])
                    eta = 2*math.pi*1
                    rotation = random.uniform(-eta, eta)
                    sections = part.divide(2)
                    self.shape[index:index+1] = sections
                    D = random.choice(['forward', 'backward'])
                    self.rotate_section(index, part.midpoint(), rotation, direction=D)
    #                 add undo function
                    if self.intersects_self():
                        self.rotate_section(index, part.midpoint(), -rotation, direction=D)
                        self.shape[index:index+len(sections)] = [part]
                    else:
                        success = True
                        break
                if not success:
                    print(f'Could not find suitable configuration within {attempts} attempts')

#             print(part.midpoint(), self.shape)
        return self

# F = Foldable(Segment(Point2D(0, 0), Point2D(100, 0)), Manifold())
F = Foldable(Line(Point((0,0)), Point((200,0))), Manifold())
for i in range(10):
#     F.random_fold()
#     F.render(clear=False)
    F.random_fold(allow_intersection=False, attempts=100)

# F.render(style={'style':'stroke:hsl(0, 100%, 50%)'}).show()
F.render(clear=False).show()
# constraint optimization
# interactive mode
# add M/V fold markings
# voronoi diagram generation
# memoize intersection detection
# folding ring linkages
# numpy (syntax/style) for geometry
